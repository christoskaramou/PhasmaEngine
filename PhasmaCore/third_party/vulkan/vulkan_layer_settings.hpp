/*
 * Copyright (c) 2020-2025 Valve Corporation
 * Copyright (c) 2020-2025 LunarG, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This code was generated by Vulkan Configurator
 */

#pragma once

#include <vector>
#include <string>

#include <vulkan/vulkan.h>

struct LayerSettings;

// Possible values for `VK_LAYER_LUNARG_api_dump` layer `output_format` setting:
static const char* VL_API_DUMP_OUTPUT_FORMAT_TEXT = "text";
static const char* VL_API_DUMP_OUTPUT_FORMAT_HTML = "html";
static const char* VL_API_DUMP_OUTPUT_FORMAT_JSON = "json";

//LunarG API dump layer
// ==========================================
// VK_LAYER_LUNARG_api_dump - 1.4.335 (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
/*
The API Dump utility layer prints API calls, parameters, and values to the identified output stream.
*/
// For more information about the layer: https://vulkan.lunarg.com/doc/sdk/latest/windows/api_dump_layer.html
struct ApidumpSettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 335, 0);

	// Output Range
	// ------------------------------------------
	// output_range (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Comma separated list of frames to output or a range of frames with a start,
	// count, and optional interval separated by a dash. A count of 0 will output
	// every frame after the start of the range. Example: "5-8-2" will output frame
	// 5, continue until frame 13, dumping every other frame. Example: "3,8-2" will
	// output frames 3, 8, and 9.
	std::string output_range = "0-0";

	// Output Format
	// ------------------------------------------
	// output_format (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies the format used for output; can be HTML, JSON, or  Text (default --
	// outputs plain text)
	// This setting has sub-settings:
	// - VkBool32 pre_dump = VK_FALSE;
	std::string output_format = VL_API_DUMP_OUTPUT_FORMAT_TEXT;

	// Pre-dump the parameters.
	// ------------------------------------------
	// pre_dump (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Setting this to true causes parameters to calls be logged before the function
	// as well as after the function.
	// This setting requires ALL of the following values:
	// - std::string output_format = VL_API_DUMP_OUTPUT_FORMAT_TEXT;
	VkBool32 pre_dump = VK_FALSE;

	// Output to File
	// ------------------------------------------
	// file (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Setting this to true indicates that output should be written to file instead
	// of stdout
	// This setting has sub-settings:
	// - std::string log_filename = "stdout";
	VkBool32 file = VK_FALSE;

	// Log Filename
	// ------------------------------------------
	// log_filename (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies the file to dump to when output files are enabled
	// This setting requires ALL of the following values:
	// - VkBool32 file = VK_TRUE;
	std::string log_filename = "stdout";

	// Log Flush After Write
	// ------------------------------------------
	// flush (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Setting this to true causes IO to be flushed after each API call that is
	// written
	VkBool32 flush = VK_TRUE;

	// Name Size
	// ------------------------------------------
	// name_size (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// The number of characters the name of a variable should consume, assuming more
	// are not required
	int32_t name_size = 32;

	// Show Types
	// ------------------------------------------
	// show_types (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Dump types in addition to values
	// This setting has sub-settings:
	// - int32_t type_size = 0;
	VkBool32 show_types = VK_TRUE;

	// Type Size
	// ------------------------------------------
	// type_size (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// The number of characters the name of a type should consume, assuming more are
	// not required
	// This setting requires ALL of the following values:
	// - VkBool32 show_types = VK_TRUE;
	int32_t type_size = 0;

	// Show Timestamp
	// ------------------------------------------
	// timestamp (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Show the timestamp of function calls since start in microseconds
	VkBool32 timestamp = VK_FALSE;

	// Show Shader
	// ------------------------------------------
	// show_shader (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Dump the shader binary code in pCode as an hex array which can be viewed in
	// https://www.khronos.org/spir/visualizer/
	VkBool32 show_shader = VK_FALSE;

	// Show Parameter Details
	// ------------------------------------------
	// detailed (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Dump parameter details in addition to API calls
	VkBool32 detailed = VK_TRUE;

	// Hide Addresses
	// ------------------------------------------
	// no_addr (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Dump "address" in place of hex addresses
	VkBool32 no_addr = VK_FALSE;

	// Use Spaces
	// ------------------------------------------
	// use_spaces (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Setting this to true causes all tab characters to be replaced with spaces
	// This setting has sub-settings:
	// - int32_t indent_size = 4;
	VkBool32 use_spaces = VK_TRUE;

	// Indent Size
	// ------------------------------------------
	// indent_size (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies the number of spaces that a tab is equal to
	// This setting requires ALL of the following values:
	// - VkBool32 use_spaces = VK_TRUE;
	int32_t indent_size = 4;

	// Show Thread and Frame
	// ------------------------------------------
	// show_thread_and_frame (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Show the thread and frame of each function called
	VkBool32 show_thread_and_frame = VK_TRUE;

private:
	friend struct LayerSettings;

	void init() {
	}
};

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_queue_submits` setting:
static const char* VL_CRASH_DIAGNOSTIC_DUMP_QUEUE_SUBMITS_RUNNING = "running";
static const char* VL_CRASH_DIAGNOSTIC_DUMP_QUEUE_SUBMITS_PENDING = "pending";

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_command_buffers` setting:
static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMAND_BUFFERS_RUNNING = "running";
static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMAND_BUFFERS_PENDING = "pending";
static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMAND_BUFFERS_ALL = "all";

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_commands` setting:
static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMANDS_RUNNING = "running";
static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMANDS_PENDING = "pending";
static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMANDS_ALL = "all";

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_shaders` setting:
static const char* VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_OFF = "off";
static const char* VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_ON_CRASH = "on_crash";
static const char* VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_ON_BIND = "on_bind";
static const char* VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_ALL = "all";

// Possible values for VK_LAYER_LUNARG_crash_diagnostic layer message_severity setting:
static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_ERROR = "error";
static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_WARN = "warn";
static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_INFO = "info";
static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_VERBOSE = "verbose";

//Crash Diagnostic Layer is a crash/hang debugging tool that helps determines GPU progress in a Vulkan application.
// ==========================================
// VK_LAYER_LUNARG_crash_diagnostic - 1.4.335 (BETA) (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
// For more information about the layer: https://vulkan.lunarg.com/doc/sdk/latest/windows/crash_diagnostic_layer.html
struct CrashdiagnosticSettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 335, 0);

	// Synchronize commands
	// ------------------------------------------
	// sync_after_commands (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Add pipeline barriers after instrumented commands to help identify whether a
	// Vulkan crash is due to a synchronization issue.
	// VK_KHR_dynamic_rendering usage is required for this feature otherwise Validation layer errors will be generated.
	VkBool32 sync_after_commands = VK_FALSE;

	// Add markers on each Vulkan command
	// ------------------------------------------
	// instrument_all_commands (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Include completion markers around every vulkan command
	// This may allow more accuratute fault locations at the expense of larger command buffers and reduced performance
	VkBool32 instrument_all_commands = VK_FALSE;

	// Track semaphores
	// ------------------------------------------
	// track_semaphores (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Include semaphore state reporting in runtime logging and dump files
	// VK_AMD_buffer_marker is required for this feature
	VkBool32 track_semaphores = VK_TRUE;

	// Watchdog timeout (ms)
	// ------------------------------------------
	// watchdog_timeout_ms (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// If set to a non-zero number, a watchdog thread will be created.
	// This will trigger if the application fails to submit new commands within a set time (in milliseconds) and a log will be created as if the a lost device error was encountered.
	int32_t watchdog_timeout_ms = 30000;

	// Output Path
	// ------------------------------------------
	// output_path (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// The directory where dump files and shader binaries are written.
	std::string output_path = "";

	// Dump queue submissions
	// ------------------------------------------
	// dump_queue_submits (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control which queue submissions are included in the dump.
	std::string dump_queue_submits = VL_CRASH_DIAGNOSTIC_DUMP_QUEUE_SUBMITS_RUNNING;

	// Dump command buffers
	// ------------------------------------------
	// dump_command_buffers (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control which command buffers are included in the dump.
	std::string dump_command_buffers = VL_CRASH_DIAGNOSTIC_DUMP_COMMAND_BUFFERS_RUNNING;

	// Dump commands
	// ------------------------------------------
	// dump_commands (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control which commands are included in the dump.
	std::string dump_commands = VL_CRASH_DIAGNOSTIC_DUMP_COMMANDS_RUNNING;

	// Dump shaders
	// ------------------------------------------
	// dump_shaders (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control of shader dumping.
	std::string dump_shaders = VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_OFF;

	// Log Filename
	// ------------------------------------------
	// log_file (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// none = no logging, stderr or stdout = to the console, otherwise an absolute or
	// relative path.
	std::string log_file = "stderr";

	// Log main submission and synchronization Vulkan commands
	// ------------------------------------------
	// trace_on (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Add Vulkan API calls intercepted by the layer will be logged to the console.
	// This includes: vkDeviceWaitIdle, vkQueueWaitIdle, vkQueuePresentKHR, vkWaitForFences, vkGetFenceStatus, vkAcquireNextImageKHR, vkCreateCommandPool, vkDestroyCommandPool, vkResetCommandPool, vkAllocateCommandBuffers, vkFreeCommandBuffers, vkQueueSubmit, vkQueueSubmit2, vkQueueSubmit2KHR and vkQueueBindSparse
	VkBool32 trace_on = VK_FALSE;

	// Log Vulkan commands that use semaphores
	// ------------------------------------------
	// trace_all_semaphores (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Add logging messages about every vulkan command that uses semaphores
	VkBool32 trace_all_semaphores = VK_FALSE;

	// Message Severity
	// ------------------------------------------
	// message_severity (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Comma-delineated list of options specifying the types of log messages to be
	// reported.
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> message_severity = {VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_ERROR};

private:
	friend struct LayerSettings;

	std::vector<const char*> message_severity_info;
	void init() {
		this->message_severity_info.resize(this->message_severity.size());
		for (std::size_t i = 0, n = message_severity_info.size(); i < n; ++i) {
			this->message_severity_info[i] = this->message_severity[i].c_str();
		}
	}
};

// Possible values for `VK_LAYER_LUNARG_gfxreconstruct` layer `capture_trigger` setting:
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_ = "";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F1 = "F1";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F2 = "F2";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F3 = "F3";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F4 = "F4";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F5 = "F5";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F6 = "F6";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F7 = "F7";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F8 = "F8";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F9 = "F9";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F10 = "F10";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F11 = "F11";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_F12 = "F12";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_TAB = "TAB";
static const char* VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_CONTROL = "CONTROL";

// Possible values for `VK_LAYER_LUNARG_gfxreconstruct` layer `capture_compression_type` setting:
static const char* VL_GFXRECONSTRUCT_CAPTURE_COMPRESSION_TYPE_LZ4 = "LZ4";
static const char* VL_GFXRECONSTRUCT_CAPTURE_COMPRESSION_TYPE_ZLIB = "ZLIB";
static const char* VL_GFXRECONSTRUCT_CAPTURE_COMPRESSION_TYPE_ZSTD = "ZSTD";
static const char* VL_GFXRECONSTRUCT_CAPTURE_COMPRESSION_TYPE_NONE = "NONE";

// Possible values for `VK_LAYER_LUNARG_gfxreconstruct` layer `memory_tracking_mode` setting:
static const char* VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_PAGE_GUARD = "page_guard";
static const char* VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_ASSISTED = "assisted";
static const char* VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_UNASSISTED = "unassisted";

// Possible values for `VK_LAYER_LUNARG_gfxreconstruct` layer `log_level` setting:
static const char* VL_GFXRECONSTRUCT_LOG_LEVEL_DEBUG = "debug";
static const char* VL_GFXRECONSTRUCT_LOG_LEVEL_INFO = "info";
static const char* VL_GFXRECONSTRUCT_LOG_LEVEL_WARNING = "warning";
static const char* VL_GFXRECONSTRUCT_LOG_LEVEL_ERROR = "error";
static const char* VL_GFXRECONSTRUCT_LOG_LEVEL_FATAL = "fatal";

//GFXReconstruct Capture Layer Version 1.0.5
// ==========================================
// VK_LAYER_LUNARG_gfxreconstruct - 1.4.335 (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
/*
The GFXReconstruct Capture Layer intercepts Vulkan API calls and logs them to a capture file. Other tools in the GFXReconstruct suite can inspect, modify, or replay capture files generated by this component.
*/
// For more information about the layer: https://vulkan.lunarg.com/doc/sdk/latest/windows/capture_tools.html
struct GfxreconstructSettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 335, 0);

	// Hotkey Capture Trigger
	// ------------------------------------------
	// capture_trigger (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specify a hotkey (any one of F1-F12, TAB, CONTROL) that will be used to
	// start/stop capture. Example: F3 will set the capture trigger to F3 hotkey. One
	// capture file will be generated for each pair of start/stop hotkey presses.
	// Default is: Empty string (hotkey capture trigger is disabled).
	std::string capture_trigger = VL_GFXRECONSTRUCT_CAPTURE_TRIGGER_;

	// Hotkey Capture Frame Limit
	// ------------------------------------------
	// capture_trigger_frames (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specify a limit on the number of frames to be captured via hotkey. Example: 1
	// will capture exactly one frame when the trigger key is pressed. Default is:
	// Empty string (no limit)
	std::string capture_trigger_frames = "";

	// Capture Specific Frames
	// ------------------------------------------
	// capture_frames (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specify one or more comma-separated frame ranges to capture. Each range will
	// be written to its own file. A frame range can be specified as a single value,
	// to specify a single frame to capture, or as two hyphenated values, to specify
	// the first and last frame to capture. Frame ranges should be specified in
	// ascending order and cannot overlap. Note that frame numbering is 1-based (i.e.
	// the first frame is frame 1). Example: 200,301-305 will create two capture
	// files, one containing a single frame and one containing five frames. Default
	// is: Empty string (all frames are captured).
	std::string capture_frames = "";

	// Capture Specific process
	// ------------------------------------------
	// capture_process_name (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specify one process name to capture.
	std::string capture_process_name = "";

	// Capture File Name
	// ------------------------------------------
	// capture_file (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Path to use when creating the capture file. Default is: gfxrecon_capture.gfxr
	// This setting has sub-settings:
	// - VkBool32 capture_file_timestamp = VK_TRUE;
	// - VkBool32 capture_file_flush = VK_FALSE;
	std::string capture_file = "gfxrecon_capture.gfxr";

	// Capture File Name with Timestamp
	// ------------------------------------------
	// capture_file_timestamp (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Add a timestamp (yyyymmddThhmmss) postfix to the capture file name.
	VkBool32 capture_file_timestamp = VK_TRUE;

	// Capture File Flush After Write
	// ------------------------------------------
	// capture_file_flush (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Flush output stream after each packet is written to the capture file. Default
	// is: false.
	VkBool32 capture_file_flush = VK_FALSE;

	// Compression Format
	// ------------------------------------------
	// capture_compression_type (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Compression format to use with the capture file. Valid values are: LZ4, ZLIB,
	// ZSTD, and NONE. Default is: LZ4
	std::string capture_compression_type = VL_GFXRECONSTRUCT_CAPTURE_COMPRESSION_TYPE_LZ4;

	// Capture Environment
	// ------------------------------------------
	// capture_environment (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// List of environment variables to capture.
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> capture_environment = {};

	// Memory Tracking Mode
	// ------------------------------------------
	// memory_tracking_mode (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies the memory tracking mode to use for detecting modifications to
	// mapped Vulkan memory objects. Available options are: page_guard, assisted, and
	// unassisted.
	// This setting has sub-settings:
	// - VkBool32 page_guard_copy_on_map = VK_TRUE;
	// - VkBool32 page_guard_separate_read = VK_TRUE;
	// - VkBool32 page_guard_external_memory = VK_FALSE;
	// - VkBool32 page_guard_persistent_memory = VK_FALSE;
	// - VkBool32 page_guard_align_buffer_sizes = VK_TRUE;
	// - VkBool32 page_guard_unblock_sigsegv = VK_FALSE;
	std::string memory_tracking_mode = VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_PAGE_GUARD;

	// Page Guard Copy on Map
	// ------------------------------------------
	// page_guard_copy_on_map (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// When the page_guard memory tracking mode is enabled, copies the content of the
	// mapped memory to the shadow memory immediately after the memory is mapped.
	// This setting requires ALL of the following values:
	// - std::string memory_tracking_mode = VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_PAGE_GUARD;
	VkBool32 page_guard_copy_on_map = VK_TRUE;

	// Page Guard Separate Read Tracking
	// ------------------------------------------
	// page_guard_separate_read (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// When the page_guard memory tracking mode is enabled, copies the content of
	// pages accessed for read from mapped memory to shadow memory on each read. Can
	// overwrite unprocessed shadow memory content when an application is reading
	// from and writing to the same page.
	// This setting requires ALL of the following values:
	// - std::string memory_tracking_mode = VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_PAGE_GUARD;
	VkBool32 page_guard_separate_read = VK_TRUE;

	// Page Guard External Memory
	// ------------------------------------------
	// page_guard_external_memory (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// When the page_guard memory tracking mode is enabled, use the
	// VK_EXT_external_memory_host extension to eliminate the need for shadow memory
	// allocations. For each memory allocation from a host visible memory type, the
	// capture layer will create an allocation from system memory, which it can
	// monitor for write access, and provide that allocation to vkAllocateMemory as
	// external memory. Only available on Windows.
	// This setting requires ALL of the following values:
	// - std::string memory_tracking_mode = VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_PAGE_GUARD;
	VkBool32 page_guard_external_memory = VK_FALSE;

	// Page Guard Persistent Memory
	// ------------------------------------------
	// page_guard_persistent_memory (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// When the page_guard memory tracking mode is enabled, this option changes the
	// way that the shadow memory used to detect modifications to mapped memory is
	// allocated. The default behavior is to allocate and copy the mapped memory
	// range on map and free the allocation on unmap. When this option is enabled, an
	// allocation with a size equal to that of the object being mapped is made once
	// on the first map and is not freed until the object is destroyed. This option
	// is intended to be used with applications that frequently map and unmap large
	// memory ranges, to avoid frequent allocation and copy operations that can have
	// a negative impact on performance. This option is ignored when
	// GFXRECON_PAGE_GUARD_EXTERNAL_MEMORY is enabled.
	// This setting requires ALL of the following values:
	// - std::string memory_tracking_mode = VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_PAGE_GUARD;
	// - VkBool32 page_guard_external_memory = VK_FALSE;
	VkBool32 page_guard_persistent_memory = VK_FALSE;

	// Page Guard Align Buffer Sizes
	// ------------------------------------------
	// page_guard_align_buffer_sizes (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// When the page_guard memory tracking mode is enabled, this option overrides the
	// Vulkan API calls that report buffer memory properties to report that buffer
	// sizes and alignments must be a multiple of the system page size. This option
	// is intended to be used with applications that perform CPU writes and GPU
	// writes/copies to different buffers that are bound to the same page of mapped
	// memory, which may result in data being lost when copying pages from the
	// page_guard shadow allocation to the real allocation. This data loss can result
	// in visible corruption during capture. Forcing buffer sizes and alignments to a
	// multiple of the system page size prevents multiple buffers from being bound to
	// the same page, avoiding data loss from simultaneous CPU writes to the shadow
	// allocation and GPU writes to the real allocation for different buffers bound
	// to the same page. This option is only available for the Vulkan API.
	// This setting requires ALL of the following values:
	// - std::string memory_tracking_mode = VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_PAGE_GUARD;
	// - VkBool32 page_guard_external_memory = VK_FALSE;
	VkBool32 page_guard_align_buffer_sizes = VK_TRUE;

	// Page Guard unblock SIGSEGV from thread's signal mask
	// ------------------------------------------
	// page_guard_unblock_sigsegv (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// When the page_guard memory tracking mode is enabled, this option overrides
	// enables SIGSEGV in thread's signal mask in the case that it has been disabled.
	// This setting requires ALL of the following values:
	// - std::string memory_tracking_mode = VL_GFXRECONSTRUCT_MEMORY_TRACKING_MODE_PAGE_GUARD;
	// - VkBool32 page_guard_external_memory = VK_FALSE;
	VkBool32 page_guard_unblock_sigsegv = VK_FALSE;

	// Level
	// ------------------------------------------
	// log_level (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specify the minimum severity level of messages to log. Options are: debug,
	// info, warning, error, and fatal. The specified level and all higher levels
	// will be enabled for logging. For example, choosing the warning level will also
	// enable the error and fatal levels.
	std::string log_level = VL_GFXRECONSTRUCT_LOG_LEVEL_INFO;

	// Log Name and Line Number
	// ------------------------------------------
	// log_detailed (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Include name and line number from the file responsible.
	VkBool32 log_detailed = VK_FALSE;

	// Apply additional indentation
	// ------------------------------------------
	// log_allow_indents (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Apply additional indentation formatting to log messages.
	VkBool32 log_allow_indents = VK_FALSE;

	// Log Output to Console / stdout
	// ------------------------------------------
	// log_output_to_console (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Log messages will be written to stdout.
	VkBool32 log_output_to_console = VK_TRUE;

	// Trigger Debug Break on Error
	// ------------------------------------------
	// log_break_on_error (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Trigger a debug break when logging an error.
	VkBool32 log_break_on_error = VK_FALSE;

	// Log Output to Debug Console
	// ------------------------------------------
	// log_output_to_os_debug_string (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Windows only option. Log messages will be written to the Debug Console with
	// OutputDebugStringA
	VkBool32 log_output_to_os_debug_string = VK_FALSE;

	// Log File
	// ------------------------------------------
	// log_file (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// When set, log messages will be written to a file at the specified path.
	// Default is: Empty string (file logging disabled).
	// This setting has sub-settings:
	// - VkBool32 log_file_flush_after_write = VK_FALSE;
	// - VkBool32 log_file_keep_open = VK_TRUE;
	// - VkBool32 log_file_create_new = VK_TRUE;
	std::string log_file = "";

	// Log File Flush After Write
	// ------------------------------------------
	// log_file_flush_after_write (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Flush the log file to disk after each write when true.
	VkBool32 log_file_flush_after_write = VK_FALSE;

	// Log File Keep Open
	// ------------------------------------------
	// log_file_keep_open (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Keep the log file open between log messages when true, or close and reopen the
	// log file for each message when false.
	VkBool32 log_file_keep_open = VK_TRUE;

	// Log File Overwrite
	// ------------------------------------------
	// log_file_create_new (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies that log file initialization should overwrite an existing file when
	// true, or append to an existing file when false.
	VkBool32 log_file_create_new = VK_TRUE;

private:
	friend struct LayerSettings;

	std::vector<const char*> capture_environment_info;
	void init() {
		this->capture_environment_info.resize(this->capture_environment.size());
		for (std::size_t i = 0, n = capture_environment_info.size(); i < n; ++i) {
			this->capture_environment_info[i] = this->capture_environment[i].c_str();
		}
	}
};

// Possible values for `VK_LAYER_LUNARG_screenshot` layer `format` setting:
static const char* VL_SCREENSHOT_FORMAT_UNORM = "UNORM";
static const char* VL_SCREENSHOT_FORMAT_SNORM = "SNORM";
static const char* VL_SCREENSHOT_FORMAT_USCALED = "USCALED";
static const char* VL_SCREENSHOT_FORMAT_SSCALED = "SSCALED";
static const char* VL_SCREENSHOT_FORMAT_UINT = "UINT";
static const char* VL_SCREENSHOT_FORMAT_SINT = "SINT";
static const char* VL_SCREENSHOT_FORMAT_SRGB = "SRGB";
static const char* VL_SCREENSHOT_FORMAT_USE_SWAPCHAIN_COLORSPACE = "USE_SWAPCHAIN_COLORSPACE";

//LunarG image capture layer
// ==========================================
// VK_LAYER_LUNARG_screenshot - 1.4.335 (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
/*
The screenshot layer records frames to image files.
*/
// For more information about the layer: https://vulkan.lunarg.com/doc/sdk/latest/windows/screenshot_layer.html
struct ScreenshotSettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 335, 0);

	// Frames
	// ------------------------------------------
	// frames (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies list of frames to output as screenshots. It is specified as a
	// comma-separated list of frames or a range of frames with a start, count, and
	// optional interval separated by a dash. Setting the variable to "all" will
	// output every frame. Example: "5-8-2" will output frame 5, continue until frame
	// 13, dumping every other frame. Example: "3,8-2" will output frames 3, 8, and
	// 9. If it is not set or it set to an empty string, no screenshots are created.
	std::string frames = "";

	// Directory
	// ------------------------------------------
	// dir (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies the directory in which to create the screenshot files. If it is not
	// set or is set to an empty string, the files will be created in the current
	// working directory.
	std::string dir = "";

	// Format
	// ------------------------------------------
	// format (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specify a color space for the output. If it is not set, set to null, or set to
	// USE_SWAPCHAIN_COLORSPACE the format will be set to use the same color space as
	// the swapchain object.
	std::string format = VL_SCREENSHOT_FORMAT_USE_SWAPCHAIN_COLORSPACE;

private:
	friend struct LayerSettings;

	void init() {
	}
};

// Possible values for VK_LAYER_KHRONOS_validation layer debug_action setting:
static const char* VL_VALIDATION_DEBUG_ACTION_VK_DBG_LAYER_ACTION_LOG_MSG = "VK_DBG_LAYER_ACTION_LOG_MSG";
static const char* VL_VALIDATION_DEBUG_ACTION_VK_DBG_LAYER_ACTION_DEBUG_OUTPUT = "VK_DBG_LAYER_ACTION_DEBUG_OUTPUT";
static const char* VL_VALIDATION_DEBUG_ACTION_VK_DBG_LAYER_ACTION_BREAK = "VK_DBG_LAYER_ACTION_BREAK";

// Possible values for VK_LAYER_KHRONOS_validation layer report_flags setting:
static const char* VL_VALIDATION_REPORT_FLAGS_INFO = "info";
static const char* VL_VALIDATION_REPORT_FLAGS_WARN = "warn";
static const char* VL_VALIDATION_REPORT_FLAGS_PERF = "perf";
static const char* VL_VALIDATION_REPORT_FLAGS_ERROR = "error";
static const char* VL_VALIDATION_REPORT_FLAGS_DEBUG = "debug";

//Khronos Validation Layer
// ==========================================
// VK_LAYER_KHRONOS_validation - 1.4.335 (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
/*
The main, comprehensive Khronos validation layer.

Vulkan is an Explicit API, enabling direct control over how GPUs actually work. By design, minimal error checking is done inside a Vulkan driver. Applications have full control and responsibility for correct operation. Any errors in how Vulkan is used can result in a crash. 

The Khronos Validation Layer can be enabled to assist development by enabling developers to verify their applications correctly use the Vulkan API.
*/
// For more information about the layer: https://vulkan.lunarg.com/doc/sdk/latest/windows/khronos_validation_layer.html
struct ValidationSettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 335, 0);

	// Fine Grained Locking
	// ------------------------------------------
	// fine_grained_locking (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Enable fine grained locking for Core Validation, which should improve
	// performance in multithreaded applications. This setting allows the
	// optimization to be disabled for debugging.
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/fine_grained_locking_usage.md
	VkBool32 fine_grained_locking = VK_TRUE;

	// Core
	// ------------------------------------------
	// validate_core (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// The main, heavy-duty validation checks. This may be valuable early in the
	// development cycle to reduce validation output while correcting
	// parameter/object usage errors.
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/core_checks.md
	// This setting has sub-settings:
	// - VkBool32 check_image_layout = VK_TRUE;
	// - VkBool32 check_command_buffer = VK_TRUE;
	// - VkBool32 check_object_in_use = VK_TRUE;
	// - VkBool32 check_query = VK_TRUE;
	// - VkBool32 check_shaders = VK_TRUE;
	VkBool32 validate_core = VK_TRUE;

	// Image Layout
	// ------------------------------------------
	// check_image_layout (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Check that the layout of each image subresource is correct whenever it is used
	// by a command buffer. These checks are very CPU intensive for some
	// applications.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_core = VK_TRUE;
	VkBool32 check_image_layout = VK_TRUE;

	// Command Buffer State
	// ------------------------------------------
	// check_command_buffer (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Check that all Vulkan objects used by a command buffer have not been
	// destroyed. These checks can be CPU intensive for some applications.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_core = VK_TRUE;
	VkBool32 check_command_buffer = VK_TRUE;

	// Object in Use
	// ------------------------------------------
	// check_object_in_use (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Check that Vulkan objects are not in use by a command buffer when they are
	// destroyed.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_core = VK_TRUE;
	VkBool32 check_object_in_use = VK_TRUE;

	// Query
	// ------------------------------------------
	// check_query (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Checks for commands that use VkQueryPool objects.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_core = VK_TRUE;
	VkBool32 check_query = VK_TRUE;

	// Shader
	// ------------------------------------------
	// check_shaders (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// This will validate the contents of the SPIR-V which can be CPU intensive
	// during application start up. This does internal checks as well as calling
	// spirv-val. (Same effect using VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT)
	// This setting has sub-settings:
	// - VkBool32 check_shaders_caching = VK_TRUE;
	// - VkBool32 debug_disable_spirv_val = VK_FALSE;
	// This setting requires ALL of the following values:
	// - VkBool32 validate_core = VK_TRUE;
	VkBool32 check_shaders = VK_TRUE;

	// Caching
	// ------------------------------------------
	// check_shaders_caching (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Creates an internal instance of VK_EXT_validation_cache and upon
	// vkDestroyInstance, will cache the shader validation so sequential usage of the
	// validation layers will be skipped.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_core = VK_TRUE;
	// - VkBool32 check_shaders = VK_TRUE;
	VkBool32 check_shaders_caching = VK_TRUE;

	// Disable spirv-val
	// ------------------------------------------
	// debug_disable_spirv_val (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Allows normal shader validation to run, but removes just spirv-val for
	// performance reasons
	VkBool32 debug_disable_spirv_val = VK_FALSE;

	// Handle Wrapping
	// ------------------------------------------
	// unique_handles (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Handle wrapping checks. Disable this feature if you are experiencing crashes
	// when creating new extensions or developing new Vulkan objects/structures.
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/handle_wrapping.md
	VkBool32 unique_handles = VK_TRUE;

	// Object Lifetime
	// ------------------------------------------
	// object_lifetime (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Object tracking checks. This may not always be necessary late in a development
	// cycle.
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/object_lifetimes.md
	VkBool32 object_lifetime = VK_TRUE;

	// Stateless Parameter
	// ------------------------------------------
	// stateless_param (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Stateless parameter checks. This may not always be necessary late in a
	// development cycle.
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/stateless_validation.md
	VkBool32 stateless_param = VK_TRUE;

	// Legacy Detection
	// ------------------------------------------
	// legacy_detection (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Give warnings when using legacy parts of the API.
	VkBool32 legacy_detection = VK_FALSE;

	// Thread Safety
	// ------------------------------------------
	// thread_safety (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Thread checks. In order to not degrade performance, it might be best to run
	// your program with thread-checking disabled most of the time, enabling it
	// occasionally for a quick sanity check or when debugging difficult application
	// behaviors.
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/thread_safety.md
	VkBool32 thread_safety = VK_TRUE;

	// Synchronization
	// ------------------------------------------
	// validate_sync (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Check for resource access conflicts caused by missing or incorrectly used
	// synchronization operations.
	// For more information about the feature: https://vulkan.lunarg.com/doc/sdk/1.4.335.0/windows/synchronization_usage.html
	// This setting has sub-settings:
	// - VkBool32 syncval_submit_time_validation = VK_TRUE;
	// - VkBool32 syncval_shader_accesses_heuristic = VK_FALSE;
	 // - khronos_validation.syncval_reporting (Setting Group)
	VkBool32 validate_sync = VK_FALSE;

	// Submit time validation
	// ------------------------------------------
	// syncval_submit_time_validation (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Enable synchronization validation on the boundary between submitted command
	// buffers. This also validates accesses from presentation operations. This
	// option can incur a significant performance cost.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_sync = VK_TRUE;
	VkBool32 syncval_submit_time_validation = VK_TRUE;

	// Shader accesses heuristic
	// ------------------------------------------
	// syncval_shader_accesses_heuristic (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Take into account memory accesses performed by the shader based on SPIR-V
	// static analysis. Warning: can produce false-positives, can ignore certain
	// types of accesses, does not support VK_EXT_descriptor_buffer.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_sync = VK_TRUE;
	VkBool32 syncval_shader_accesses_heuristic = VK_FALSE;

	// Extra properties
	// ------------------------------------------
	// syncval_message_extra_properties (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Append a section of key-value properties to the error message. Useful for
	// filtering errors.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_sync = VK_TRUE;
	VkBool32 syncval_message_extra_properties = VK_FALSE;

	// Debug Printf only preset
	// ------------------------------------------
	// printf_only_preset (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// A single, quick setting to turn on only DebugPrintf and turn off everything
	// else
	VkBool32 printf_only_preset = VK_FALSE;

	// Debug Printf
	// ------------------------------------------
	// printf_enable (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Enable DebugPrintf and will print anything use NonSemantic.DebugPrintf in
	// their SPIR-V
	// For more information about the feature: https://vulkan.lunarg.com/doc/sdk/1.4.335.0/windows/debug_printf.html
	// This setting has sub-settings:
	// - VkBool32 printf_to_stdout = VK_TRUE;
	// - VkBool32 printf_verbose = VK_FALSE;
	// - int32_t printf_buffer_size = 1024;
	VkBool32 printf_enable = VK_FALSE;

	// Redirect Printf messages to stdout
	// ------------------------------------------
	// printf_to_stdout (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Enable redirection of Debug Printf messages from the debug callback to stdout
	// This setting requires ALL of the following values:
	// - VkBool32 printf_enable = VK_TRUE;
	VkBool32 printf_to_stdout = VK_TRUE;

	// Printf verbose
	// ------------------------------------------
	// printf_verbose (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Will print out handles, instruction location, position in command buffer, and
	// more
	// This setting requires ALL of the following values:
	// - VkBool32 printf_enable = VK_TRUE;
	VkBool32 printf_verbose = VK_FALSE;

	// Printf buffer size
	// ------------------------------------------
	// printf_buffer_size (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Set the size in bytes of the buffer per VkCommandBuffer to hold the messages
	// (Each message is about 50 bytes)
	// This setting requires ALL of the following values:
	// - VkBool32 printf_enable = VK_TRUE;
	int32_t printf_buffer_size = 1024;

	// GPU Assisted Validation
	// ------------------------------------------
	// gpuav_enable (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Enable validation that cannot be done the CPU and needs hooks into the GPU
	// execution
	// For more information about the feature: https://vulkan.lunarg.com/doc/sdk/1.4.335.0/windows/gpu_validation.html
	// This setting has sub-settings:
	// - VkBool32 gpuav_safe_mode = VK_FALSE;
	// - VkBool32 gpuav_force_on_robustness = VK_FALSE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	// - VkBool32 gpuav_buffers_validation = VK_TRUE;
	 // - khronos_validation.gpuav_debug_settings (Setting Group)
	VkBool32 gpuav_enable = VK_FALSE;

	// Safe Mode
	// ------------------------------------------
	// gpuav_safe_mode (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Will have GPU-AV try and prevent crashes, but will be much slower to validate.
	// If using Safe Mode, consider using selective shader instrumentation, to only
	// instrument the shaders/pipelines causing issues.
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	VkBool32 gpuav_safe_mode = VK_FALSE;

	// Force on robustness features
	// ------------------------------------------
	// gpuav_force_on_robustness (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// This will enable all possible robustness features for the app at device
	// creation time. This can be used to quickly detect if with robustness, your
	// issue disappears. GPU-AV will also skip validating things already covered by
	// robustness, so turning on should reduce GPU-AV performance overhead.
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	VkBool32 gpuav_force_on_robustness = VK_FALSE;

	// Shader instrumentation
	// ------------------------------------------
	// gpuav_shader_instrumentation (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Instrument shaders to validate descriptors, descriptor indexing, buffer device
	// addresses and ray queries. Warning: will considerably slow down shader
	// executions.
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/gpu_av_shader_instrumentation.md
	// This setting has sub-settings:
	// - VkBool32 gpuav_select_instrumented_shaders = VK_FALSE;
	// - VkBool32 gpuav_descriptor_checks = VK_TRUE;
	// - VkBool32 gpuav_post_process_descriptor_indexing = VK_TRUE;
	// - VkBool32 gpuav_buffer_address_oob = VK_TRUE;
	// - VkBool32 gpuav_validate_ray_query = VK_TRUE;
	// - VkBool32 gpuav_vertex_attribute_fetch_oob = VK_TRUE;
	// - VkBool32 gpuav_shader_sanitizer = VK_TRUE;
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	VkBool32 gpuav_shader_instrumentation = VK_TRUE;

	// Enable instrumenting shaders selectively
	// ------------------------------------------
	// gpuav_select_instrumented_shaders (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Select which shaders to instrument by passing a VkValidationFeaturesEXT struct
	// with GPU-AV enabled in the VkShaderModuleCreateInfo pNext or using a regex
	// matching a shader/pipeline debug name. Because this only validates the
	// selected shaders, it will allow GPU-AV to run much faster.
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/gpu_av_selective_shader.md
	// This setting has sub-settings:
	// - std::vector<std::string> gpuav_shaders_to_instrument = {};
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	VkBool32 gpuav_select_instrumented_shaders = VK_FALSE;

	// Shader/pipeline name regexes
	// ------------------------------------------
	// gpuav_shaders_to_instrument (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Any shader or pipeline library debug name (set with
	// vkSetDebugUtilsObjectNameEXT) fully matching any listed regular expression
	// will be instrumented when creating pipelines with those shaders or libraries.
	// Regex grammar: Modified ECMAScript. No support for shader objects yet.
	// Warning: instrumentation being performed at final pipeline creation time, if
	// shaders modules have already been destroyed at this step (possible when using
	// pipeline libraries), they won't be found by this regex selection system. In
	// this case, consider naming pipeline libraries instead.
	// This setting can list multiple values using the "," (comma) separator.
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	// - VkBool32 gpuav_select_instrumented_shaders = VK_TRUE;
	std::vector<std::string> gpuav_shaders_to_instrument = {};

	// Descriptors indexing
	// ------------------------------------------
	// gpuav_descriptor_checks (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Enable descriptors and buffer out of bounds validation when using descriptor
	// indexing
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/gpu_av_descriptor_indexing.md
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	VkBool32 gpuav_descriptor_checks = VK_TRUE;

	// Post process descriptor indexing
	// ------------------------------------------
	// gpuav_post_process_descriptor_indexing (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Track which descriptor indexes were used in shader to run normal validation
	// afterwards
	// For more information about the feature: https://github.com/KhronosGroup/Vulkan-ValidationLayers/blob/main/docs/gpu_av_post_process.md
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	VkBool32 gpuav_post_process_descriptor_indexing = VK_TRUE;

	// Out of bounds buffer device addresses
	// ------------------------------------------
	// gpuav_buffer_address_oob (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Check for invalid access using buffer device address
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	VkBool32 gpuav_buffer_address_oob = VK_TRUE;

	// RayQuery SPIR-V instructions
	// ------------------------------------------
	// gpuav_validate_ray_query (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Enable shader instrumentation on OpRayQueryInitializeKHR
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	VkBool32 gpuav_validate_ray_query = VK_TRUE;

	// Out of bounds vertex attribute fetching
	// ------------------------------------------
	// gpuav_vertex_attribute_fetch_oob (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate that no vertex attribute fetching is out of bonds
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	VkBool32 gpuav_vertex_attribute_fetch_oob = VK_TRUE;

	// Shader Sanitizer
	// ------------------------------------------
	// gpuav_shader_sanitizer (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Things invalid to do in SPIR-V but don't have a dedicated check (example:
	// dividing an int by zero, reaching OpUnreachable, invalid casting,
	// overflow/undeflow). When in safe mode, will modify the invalid usage.
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_shader_instrumentation = VK_TRUE;
	VkBool32 gpuav_shader_sanitizer = VK_TRUE;

	// Buffer content validation
	// ------------------------------------------
	// gpuav_buffers_validation (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate buffers containing parameters used in indirect Vulkan commands, or
	// used in copy commands
	// This setting has sub-settings:
	// - VkBool32 gpuav_indirect_draws_buffers = VK_TRUE;
	// - VkBool32 gpuav_indirect_dispatches_buffers = VK_TRUE;
	// - VkBool32 gpuav_indirect_trace_rays_buffers = VK_TRUE;
	// - VkBool32 gpuav_buffer_copies = VK_TRUE;
	// - VkBool32 gpuav_copy_memory_indirect = VK_TRUE;
	// - VkBool32 gpuav_index_buffers = VK_TRUE;
	// - VkBool32 gpuav_acceleration_structures_builds = VK_TRUE;
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	VkBool32 gpuav_buffers_validation = VK_TRUE;

	// Indirect draws parameters
	// ------------------------------------------
	// gpuav_indirect_draws_buffers (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate buffers containing draw parameters used in indirect draw commands.
	// Includes vkCmdDrawMeshTasks* calls as well
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_buffers_validation = VK_TRUE;
	VkBool32 gpuav_indirect_draws_buffers = VK_TRUE;

	// Indirect dispatches parameters
	// ------------------------------------------
	// gpuav_indirect_dispatches_buffers (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate buffers containing dispatch parameters used in indirect dispatch
	// commands
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_buffers_validation = VK_TRUE;
	VkBool32 gpuav_indirect_dispatches_buffers = VK_TRUE;

	// Indirect trace rays parameters
	// ------------------------------------------
	// gpuav_indirect_trace_rays_buffers (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate buffers containing ray tracing parameters used in indirect ray
	// tracing commands
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_buffers_validation = VK_TRUE;
	VkBool32 gpuav_indirect_trace_rays_buffers = VK_TRUE;

	// Buffer copies
	// ------------------------------------------
	// gpuav_buffer_copies (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate copies involving a VkBuffer. Right now only validates copy buffer to
	// image.
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_buffers_validation = VK_TRUE;
	VkBool32 gpuav_buffer_copies = VK_TRUE;

	// VK_KHR_copy_memory_indirect
	// ------------------------------------------
	// gpuav_copy_memory_indirect (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate VK_KHR_copy_memory_indirect.
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_buffers_validation = VK_TRUE;
	VkBool32 gpuav_copy_memory_indirect = VK_TRUE;

	// Index buffers
	// ------------------------------------------
	// gpuav_index_buffers (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate that indexed draws do not fetch indices outside of the bounds of the
	// index buffer.
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_buffers_validation = VK_TRUE;
	VkBool32 gpuav_index_buffers = VK_TRUE;

	// Acceleration structures builds
	// ------------------------------------------
	// gpuav_acceleration_structures_builds (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Validate acceleration structures references in TLAS build commands.
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	// - VkBool32 gpuav_buffers_validation = VK_TRUE;
	VkBool32 gpuav_acceleration_structures_builds = VK_TRUE;

	// Disable all of GPU-AV
	// ------------------------------------------
	// gpuav_debug_disable_all (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Acts as a VkValidationFeatureDisableEXT to override the
	// VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT passed by the user
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	VkBool32 gpuav_debug_disable_all = VK_FALSE;

	// Validate instrumented shaders
	// ------------------------------------------
	// gpuav_debug_validate_instrumented_shaders (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Run spirv-val after doing shader instrumentation
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	VkBool32 gpuav_debug_validate_instrumented_shaders = VK_FALSE;

	// Dump instrumented shaders
	// ------------------------------------------
	// gpuav_debug_dump_instrumented_shaders (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Will dump the instrumented shaders (before and after) to working directory
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	VkBool32 gpuav_debug_dump_instrumented_shaders = VK_FALSE;

	// Limit how many time a pass can instrument the SPIR-V
	// ------------------------------------------
	// gpuav_debug_max_instrumentations_count (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Zero is same as unlimited
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	int32_t gpuav_debug_max_instrumentations_count = 0;

	// Print SPIR-V instrumentation info
	// ------------------------------------------
	// gpuav_debug_print_instrumentation_info (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Prints verbose information about the instrumentation of the SPIR-V
	// This setting requires ALL of the following values:
	// - VkBool32 gpuav_enable = VK_TRUE;
	VkBool32 gpuav_debug_print_instrumentation_info = VK_FALSE;

	// Best Practices
	// ------------------------------------------
	// validate_best_practices (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Outputs warnings related to common misuse of the API, but which are not
	// explicitly prohibited by the specification.
	// For more information about the feature: https://vulkan.lunarg.com/doc/sdk/1.4.335.0/windows/best_practices.html
	// This setting has sub-settings:
	// - VkBool32 validate_best_practices_arm = VK_FALSE;
	// - VkBool32 validate_best_practices_amd = VK_FALSE;
	// - VkBool32 validate_best_practices_img = VK_FALSE;
	// - VkBool32 validate_best_practices_nvidia = VK_FALSE;
	VkBool32 validate_best_practices = VK_FALSE;

	// ARM-specific best practices
	// ------------------------------------------
	// validate_best_practices_arm (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Outputs warnings for spec-conforming but non-ideal code on ARM GPUs.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_best_practices = VK_TRUE;
	VkBool32 validate_best_practices_arm = VK_FALSE;

	// AMD-specific best practices
	// ------------------------------------------
	// validate_best_practices_amd (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Outputs warnings for spec-conforming but non-ideal code on AMD GPUs.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_best_practices = VK_TRUE;
	VkBool32 validate_best_practices_amd = VK_FALSE;

	// IMG-specific best practices
	// ------------------------------------------
	// validate_best_practices_img (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Outputs warnings for spec-conforming but non-ideal code on Imagination GPUs.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_best_practices = VK_TRUE;
	VkBool32 validate_best_practices_img = VK_FALSE;

	// NVIDIA-specific best practices
	// ------------------------------------------
	// validate_best_practices_nvidia (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Outputs warnings for spec-conforming but non-ideal code on NVIDIA GPUs.
	// This setting requires ALL of the following values:
	// - VkBool32 validate_best_practices = VK_TRUE;
	VkBool32 validate_best_practices_nvidia = VK_FALSE;

	// Debug Action
	// ------------------------------------------
	// debug_action (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies what action is to be taken when a layer reports information
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> debug_action = {VL_VALIDATION_DEBUG_ACTION_VK_DBG_LAYER_ACTION_LOG_MSG, VL_VALIDATION_DEBUG_ACTION_VK_DBG_LAYER_ACTION_DEBUG_OUTPUT};

	// Log Filename
	// ------------------------------------------
	// log_filename (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Specifies the output filename
	std::string log_filename = "stdout";

	// Message Severity
	// ------------------------------------------
	// report_flags (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Comma-delineated list of options specifying the types of messages to be
	// reported
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> report_flags = {VL_VALIDATION_REPORT_FLAGS_ERROR};

	// Limit Duplicated Messages
	// ------------------------------------------
	// enable_message_limit (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Enable limiting of duplicate messages.
	// This setting has sub-settings:
	// - int32_t duplicate_message_limit = 10;
	VkBool32 enable_message_limit = VK_TRUE;

	// Max Duplicated Messages
	// ------------------------------------------
	// duplicate_message_limit (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Maximum number of times any single validation message should be reported.
	// This setting requires ALL of the following values:
	// - VkBool32 enable_message_limit = VK_TRUE;
	int32_t duplicate_message_limit = 10;

	// Mute Message VUIDs
	// ------------------------------------------
	// message_id_filter (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// List of VUIDs and VUID identifiers which are to be IGNORED by the validation
	// layer
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> message_id_filter = {};

	// JSON
	// ------------------------------------------
	// message_format_json (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Display Validation as JSON (VkDebugUtilsMessengerCallbackDataEXT::pMessage
	// will contain JSON)
	VkBool32 message_format_json = VK_FALSE;

	// Display Application Name
	// ------------------------------------------
	// message_format_display_application_name (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Useful when running multiple instances to know which instance the message is
	// from.
	VkBool32 message_format_display_application_name = VK_FALSE;

private:
	friend struct LayerSettings;

	std::vector<const char*> gpuav_shaders_to_instrument_info;
	std::vector<const char*> debug_action_info;
	std::vector<const char*> report_flags_info;
	std::vector<const char*> message_id_filter_info;
	void init() {
		this->gpuav_shaders_to_instrument_info.resize(this->gpuav_shaders_to_instrument.size());
		for (std::size_t i = 0, n = gpuav_shaders_to_instrument_info.size(); i < n; ++i) {
			this->gpuav_shaders_to_instrument_info[i] = this->gpuav_shaders_to_instrument[i].c_str();
		}
		this->debug_action_info.resize(this->debug_action.size());
		for (std::size_t i = 0, n = debug_action_info.size(); i < n; ++i) {
			this->debug_action_info[i] = this->debug_action[i].c_str();
		}
		this->report_flags_info.resize(this->report_flags.size());
		for (std::size_t i = 0, n = report_flags_info.size(); i < n; ++i) {
			this->report_flags_info[i] = this->report_flags[i].c_str();
		}
		this->message_id_filter_info.resize(this->message_id_filter.size());
		for (std::size_t i = 0, n = message_id_filter_info.size(); i < n; ++i) {
			this->message_id_filter_info[i] = this->message_id_filter[i].c_str();
		}
	}
};

// Possible values for VK_LAYER_KHRONOS_profiles layer simulate_capabilities setting:
static const char* VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_API_VERSION_BIT = "SIMULATE_API_VERSION_BIT";
static const char* VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_FEATURES_BIT = "SIMULATE_FEATURES_BIT";
static const char* VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_PROPERTIES_BIT = "SIMULATE_PROPERTIES_BIT";
static const char* VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_EXTENSIONS_BIT = "SIMULATE_EXTENSIONS_BIT";
static const char* VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_FORMATS_BIT = "SIMULATE_FORMATS_BIT";
static const char* VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_VIDEO_CAPABILITIES_BIT = "SIMULATE_VIDEO_CAPABILITIES_BIT";
static const char* VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_VIDEO_FORMATS_BIT = "SIMULATE_VIDEO_FORMATS_BIT";

// Possible values for `VK_LAYER_KHRONOS_profiles` layer `default_feature_values` setting:
static const char* VL_PROFILES_DEFAULT_FEATURE_VALUES_DEFAULT_FEATURE_VALUES_DEVICE = "DEFAULT_FEATURE_VALUES_DEVICE";
static const char* VL_PROFILES_DEFAULT_FEATURE_VALUES_DEFAULT_FEATURE_VALUES_FALSE = "DEFAULT_FEATURE_VALUES_FALSE";

// Possible values for `VK_LAYER_KHRONOS_profiles` layer `unknown_feature_values` setting:
static const char* VL_PROFILES_UNKNOWN_FEATURE_VALUES_UNKNOWN_FEATURE_VALUES_UNCHANGED = "UNKNOWN_FEATURE_VALUES_UNCHANGED";
static const char* VL_PROFILES_UNKNOWN_FEATURE_VALUES_UNKNOWN_FEATURE_VALUES_DEVICE = "UNKNOWN_FEATURE_VALUES_DEVICE";

// Possible values for VK_LAYER_KHRONOS_profiles layer debug_actions setting:
static const char* VL_PROFILES_DEBUG_ACTIONS_DEBUG_ACTION_STDOUT_BIT = "DEBUG_ACTION_STDOUT_BIT";
static const char* VL_PROFILES_DEBUG_ACTIONS_DEBUG_ACTION_OUTPUT_BIT = "DEBUG_ACTION_OUTPUT_BIT";
static const char* VL_PROFILES_DEBUG_ACTIONS_DEBUG_ACTION_FILE_BIT = "DEBUG_ACTION_FILE_BIT";
static const char* VL_PROFILES_DEBUG_ACTIONS_DEBUG_ACTION_BREAKPOINT_BIT = "DEBUG_ACTION_BREAKPOINT_BIT";

// Possible values for VK_LAYER_KHRONOS_profiles layer debug_reports setting:
static const char* VL_PROFILES_DEBUG_REPORTS_DEBUG_REPORT_NOTIFICATION_BIT = "DEBUG_REPORT_NOTIFICATION_BIT";
static const char* VL_PROFILES_DEBUG_REPORTS_DEBUG_REPORT_WARNING_BIT = "DEBUG_REPORT_WARNING_BIT";
static const char* VL_PROFILES_DEBUG_REPORTS_DEBUG_REPORT_ERROR_BIT = "DEBUG_REPORT_ERROR_BIT";
static const char* VL_PROFILES_DEBUG_REPORTS_DEBUG_REPORT_DEBUG_BIT = "DEBUG_REPORT_DEBUG_BIT";

//Khronos Profiles layer
// ==========================================
// VK_LAYER_KHRONOS_profiles - 1.4.335 (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
/*
The Khronos Profiles layer helps test across a wide range of hardware capabilities without requiring a physical copy of every device.
*/
// For more information about the layer: https://vulkan.lunarg.com/doc/sdk/latest/windows/profiles_layer.html
struct ProfilesSettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 335, 0);

	// Emulate a Vulkan Profile
	// ------------------------------------------
	// profile_emulation (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Emulate a Vulkan Profile on the Developer System
	// This setting has sub-settings:
	// - std::string profile_dirs = "";
	// - std::string profile_name = "${VP_DEFAULT}";
	// - VkBool32 profile_validation = VK_FALSE;
	VkBool32 profile_emulation = VK_TRUE;

	// Loading Directory
	// ------------------------------------------
	// profile_dirs (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Select the location all the profiles.
	// This setting requires ALL of the following values:
	// - VkBool32 profile_emulation = VK_TRUE;
	std::string profile_dirs = "";

	// Name
	// ------------------------------------------
	// profile_name (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Name of the profile specified by the profile file to use.
	// This setting requires ALL of the following values:
	// - VkBool32 profile_emulation = VK_TRUE;
	std::string profile_name = "${VP_DEFAULT}";

	// Schema Validation
	// ------------------------------------------
	// profile_validation (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Validate the profile files against the Vulkan SDK profile schema if the file
	// is found.
	// This setting requires ALL of the following values:
	// - VkBool32 profile_emulation = VK_TRUE;
	VkBool32 profile_validation = VK_FALSE;

	// Simulate Profile Capabilities
	// ------------------------------------------
	// simulate_capabilities (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Control of the simulated capabilities of the Vulkan physical device from the
	// selected Vulkan Profile.
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> simulate_capabilities = {VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_API_VERSION_BIT, VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_FEATURES_BIT, VL_PROFILES_SIMULATE_CAPABILITIES_SIMULATE_PROPERTIES_BIT};

	// Unspecified Features
	// ------------------------------------------
	// default_feature_values (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Feature values when not specified in the select Vulkan profiles.
	std::string default_feature_values = VL_PROFILES_DEFAULT_FEATURE_VALUES_DEFAULT_FEATURE_VALUES_DEVICE;

	// Unknown Features
	// ------------------------------------------
	// unknown_feature_values (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Feature values when unrecongnized by Vulkan profiles.
	std::string unknown_feature_values = VL_PROFILES_UNKNOWN_FEATURE_VALUES_UNKNOWN_FEATURE_VALUES_UNCHANGED;

	// Emulate VK_KHR_portability_subset
	// ------------------------------------------
	// emulate_portability (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Emulate the VK_KHR_portability_subset extension on the device.
	// This setting has sub-settings:
	// - VkBool32 constantAlphaColorBlendFactors = VK_FALSE;
	// - VkBool32 events = VK_FALSE;
	// - VkBool32 imageViewFormatReinterpretation = VK_FALSE;
	// - VkBool32 imageViewFormatSwizzle = VK_FALSE;
	// - VkBool32 imageView2DOn3DImage = VK_FALSE;
	// - VkBool32 multisampleArrayImage = VK_FALSE;
	// - VkBool32 mutableComparisonSamplers = VK_FALSE;
	// - VkBool32 pointPolygons = VK_FALSE;
	// - VkBool32 samplerMipLodBias = VK_FALSE;
	// - VkBool32 separateStencilMaskRef = VK_FALSE;
	// - VkBool32 shaderSampleRateInterpolationFunctions = VK_FALSE;
	// - VkBool32 tessellationIsolines = VK_FALSE;
	// - VkBool32 triangleFans = VK_FALSE;
	// - VkBool32 vertexAttributeAccessBeyondStride = VK_FALSE;
	VkBool32 emulate_portability = VK_TRUE;

	// constantAlphaColorBlendFactors
	// ------------------------------------------
	// constantAlphaColorBlendFactors (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports constant alpha Blend Factors
	// used as source or destination color Blending.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 constantAlphaColorBlendFactors = VK_FALSE;

	// events
	// ------------------------------------------
	// events (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports synchronization using Events
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 events = VK_FALSE;

	// imageViewFormatReinterpretation
	// ------------------------------------------
	// imageViewFormatReinterpretation (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports a VkImageView being created
	// with a texel format containing a different number of components, or a
	// different number of bits in each component, than the texel format of the
	// underlying VkImage.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 imageViewFormatReinterpretation = VK_FALSE;

	// imageViewFormatSwizzle
	// ------------------------------------------
	// imageViewFormatSwizzle (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports remapping format components
	// using VkImageViewCreateInfo::components.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 imageViewFormatSwizzle = VK_FALSE;

	// imageView2DOn3DImage
	// ------------------------------------------
	// imageView2DOn3DImage (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports a VkImage being created with
	// the VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT flag set, permitting a 2D or 2D
	// array image view to be created on a 3D VkImage.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 imageView2DOn3DImage = VK_FALSE;

	// multisampleArrayImage
	// ------------------------------------------
	// multisampleArrayImage (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports a VkImage being created as a 2D
	// array with multiple samples per texel.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 multisampleArrayImage = VK_FALSE;

	// mutableComparisonSamplers
	// ------------------------------------------
	// mutableComparisonSamplers (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation allows descriptors with comparison
	// samplers to be updated.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 mutableComparisonSamplers = VK_FALSE;

	// pointPolygons
	// ------------------------------------------
	// pointPolygons (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports Rasterization using a point
	// Polygon Mode.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 pointPolygons = VK_FALSE;

	// samplerMipLodBias
	// ------------------------------------------
	// samplerMipLodBias (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports setting a mipmap LOD bias value
	// when creating a sampler.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 samplerMipLodBias = VK_FALSE;

	// separateStencilMaskRef
	// ------------------------------------------
	// separateStencilMaskRef (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports separate front and back Stencil
	// Test reference values.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 separateStencilMaskRef = VK_FALSE;

	// shaderSampleRateInterpolationFunctions
	// ------------------------------------------
	// shaderSampleRateInterpolationFunctions (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports fragment shaders which use the
	// InterpolationFunction capability.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 shaderSampleRateInterpolationFunctions = VK_FALSE;

	// tessellationIsolines
	// ------------------------------------------
	// tessellationIsolines (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports isoline output from the
	// Tessellation stage of a graphics pipeline. This member is only meaningful if
	// tessellationShader are supported.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 tessellationIsolines = VK_FALSE;

	// triangleFans
	// ------------------------------------------
	// triangleFans (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports Triangle Fans primitive
	// topology.
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 triangleFans = VK_FALSE;

	// vertexAttributeAccessBeyondStride
	// ------------------------------------------
	// vertexAttributeAccessBeyondStride (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports accessing a vertex input
	// attribute beyond the stride of the corresponding vertex input binding.
	// This setting has sub-settings:
	// - int32_t minVertexInputBindingStrideAlignment = 4;
	// This setting requires ALL of the following values:
	// - VkBool32 emulate_portability = VK_TRUE;
	VkBool32 vertexAttributeAccessBeyondStride = VK_FALSE;

	// minVertexInputBindingStrideAlignment
	// ------------------------------------------
	// minVertexInputBindingStrideAlignment (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Indicates whether this implementation supports accessing a vertex input
	// attribute beyond the stride of the corresponding vertex input binding.
	// This setting requires ALL of the following values:
	// - VkBool32 vertexAttributeAccessBeyondStride = VK_FALSE;
	int32_t minVertexInputBindingStrideAlignment = 4;

	// Exclude Device Extensions
	// ------------------------------------------
	// exclude_device_extensions (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Removes the listed device extensions from being reported by the Vulkan
	// physical device.
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> exclude_device_extensions = {};

	// Exclude Formats
	// ------------------------------------------
	// exclude_formats (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Removes the format feature flags from being reported by the Vulkan physical
	// device.
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> exclude_formats = {};

	// Debug Actions
	// ------------------------------------------
	// debug_actions (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// This indicates what action is to be taken when a layer wants to report
	// information
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> debug_actions = {VL_PROFILES_DEBUG_ACTIONS_DEBUG_ACTION_STDOUT_BIT};

	// Log Filename
	// ------------------------------------------
	// debug_filename (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Specifies the output filename
	std::string debug_filename = "profiles_layer_log.txt";

	// Clear Log at Launch
	// ------------------------------------------
	// debug_file_clear (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Discard the content of the log file between each layer run
	VkBool32 debug_file_clear = VK_TRUE;

	// Fail on Error
	// ------------------------------------------
	// debug_fail_on_error (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// If the device doesn't support the capabilities of the selected Profile, the
	// layer fail to load. When enabled, vkEnumeratePhysicalDevices will fail when
	// the selected Profile is not supported.
	VkBool32 debug_fail_on_error = VK_FALSE;

	// Message Types
	// ------------------------------------------
	// debug_reports (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// This is a comma-delineated list of options telling the layer what types of
	// messages it should report back
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> debug_reports = {VL_PROFILES_DEBUG_REPORTS_DEBUG_REPORT_NOTIFICATION_BIT, VL_PROFILES_DEBUG_REPORTS_DEBUG_REPORT_WARNING_BIT, VL_PROFILES_DEBUG_REPORTS_DEBUG_REPORT_ERROR_BIT};

private:
	friend struct LayerSettings;

	std::vector<const char*> simulate_capabilities_info;
	std::vector<const char*> exclude_device_extensions_info;
	std::vector<const char*> exclude_formats_info;
	std::vector<const char*> debug_actions_info;
	std::vector<const char*> debug_reports_info;
	void init() {
		this->simulate_capabilities_info.resize(this->simulate_capabilities.size());
		for (std::size_t i = 0, n = simulate_capabilities_info.size(); i < n; ++i) {
			this->simulate_capabilities_info[i] = this->simulate_capabilities[i].c_str();
		}
		this->exclude_device_extensions_info.resize(this->exclude_device_extensions.size());
		for (std::size_t i = 0, n = exclude_device_extensions_info.size(); i < n; ++i) {
			this->exclude_device_extensions_info[i] = this->exclude_device_extensions[i].c_str();
		}
		this->exclude_formats_info.resize(this->exclude_formats.size());
		for (std::size_t i = 0, n = exclude_formats_info.size(); i < n; ++i) {
			this->exclude_formats_info[i] = this->exclude_formats[i].c_str();
		}
		this->debug_actions_info.resize(this->debug_actions.size());
		for (std::size_t i = 0, n = debug_actions_info.size(); i < n; ++i) {
			this->debug_actions_info[i] = this->debug_actions[i].c_str();
		}
		this->debug_reports_info.resize(this->debug_reports.size());
		for (std::size_t i = 0, n = debug_reports_info.size(); i < n; ++i) {
			this->debug_reports_info[i] = this->debug_reports[i].c_str();
		}
	}
};

//Khronos Shader object layer
// ==========================================
// VK_LAYER_KHRONOS_shader_object - 1.4.335 (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
struct ShaderobjectSettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 335, 0);

	// Force Enable
	// ------------------------------------------
	// force_enable (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Force the layer to be active even if the underlying driver also implements the
	// shader object extension.
	VkBool32 force_enable = VK_FALSE;

	// Disable Pipeline Pre-Caching
	// ------------------------------------------
	// disable_pipeline_pre_caching (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS)
	// Disable the layer from pre-caching pipelines, reducing the memory overhead.
	VkBool32 disable_pipeline_pre_caching = VK_FALSE;

private:
	friend struct LayerSettings;

	void init() {
	}
};

//Khronos Synchronization2 layer
// ==========================================
// VK_LAYER_KHRONOS_synchronization2 - 1.4.335 (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
/*
The VK_LAYER_KHRONOS_synchronization2 extension layer implements the VK_KHR_synchronization2 extension.
*/
// For more information about the layer: https://vulkan.lunarg.com/doc/sdk/latest/windows/synchronization2_layer.html
struct Synchronization2SettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 335, 0);

	// Force Enable
	// ------------------------------------------
	// force_enable (WINDOWS_X86, WINDOWS_ARM, LINUX, MACOS, ANDROID)
	// Force the layer to be active even if the underlying driver also implements the
	// synchonization2 extension.
	VkBool32 force_enable = VK_FALSE;

private:
	friend struct LayerSettings;

	void init() {
	}
};

// `LayerSettings` allows initializing layer settings from Vulkan application code.
struct LayerSettings {
	ApidumpSettingData api_dump;
	CrashdiagnosticSettingData crash_diagnostic;
	GfxreconstructSettingData gfxreconstruct;
	ScreenshotSettingData screenshot;
	ValidationSettingData validation;
	ProfilesSettingData profiles;
	ShaderobjectSettingData shader_object;
	Synchronization2SettingData synchronization2;

	// Use for VkLayerSettingsCreateInfoEXT `settingCount` and `pSettings` argument
	// Provided by VK_EXT_layer_settings
	// typedef struct VkLayerSettingsCreateInfoEXT {
	// 	VkStructureType             sType;
	// 	const void*                 pNext;
	// 	uint32_t                    settingCount;
	// 	const VkLayerSettingEXT*    pSettings;
	// } VkLayerSettingsCreateInfoEXT;
	std::vector<VkLayerSettingEXT> info() {
		this->api_dump.init();
		this->crash_diagnostic.init();
		this->gfxreconstruct.init();
		this->screenshot.init();
		this->validation.init();
		this->profiles.init();
		this->shader_object.init();
		this->synchronization2.init();

		std::vector<VkLayerSettingEXT> init{
			{"VK_LAYER_LUNARG_api_dump", "output_range", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->api_dump.output_range.c_str()},
			{"VK_LAYER_LUNARG_api_dump", "output_format", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->api_dump.output_format.c_str()},
			{"VK_LAYER_LUNARG_api_dump", "pre_dump", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.pre_dump},
			{"VK_LAYER_LUNARG_api_dump", "file", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.file},
			{"VK_LAYER_LUNARG_api_dump", "log_filename", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->api_dump.log_filename.c_str()},
			{"VK_LAYER_LUNARG_api_dump", "flush", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.flush},
			{"VK_LAYER_LUNARG_api_dump", "name_size", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &this->api_dump.name_size},
			{"VK_LAYER_LUNARG_api_dump", "show_types", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.show_types},
			{"VK_LAYER_LUNARG_api_dump", "type_size", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &this->api_dump.type_size},
			{"VK_LAYER_LUNARG_api_dump", "timestamp", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.timestamp},
			{"VK_LAYER_LUNARG_api_dump", "show_shader", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.show_shader},
			{"VK_LAYER_LUNARG_api_dump", "detailed", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.detailed},
			{"VK_LAYER_LUNARG_api_dump", "no_addr", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.no_addr},
			{"VK_LAYER_LUNARG_api_dump", "use_spaces", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.use_spaces},
			{"VK_LAYER_LUNARG_api_dump", "indent_size", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &this->api_dump.indent_size},
			{"VK_LAYER_LUNARG_api_dump", "show_thread_and_frame", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->api_dump.show_thread_and_frame},
			{"VK_LAYER_LUNARG_crash_diagnostic", "sync_after_commands", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->crash_diagnostic.sync_after_commands},
			{"VK_LAYER_LUNARG_crash_diagnostic", "instrument_all_commands", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->crash_diagnostic.instrument_all_commands},
			{"VK_LAYER_LUNARG_crash_diagnostic", "track_semaphores", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->crash_diagnostic.track_semaphores},
			{"VK_LAYER_LUNARG_crash_diagnostic", "watchdog_timeout_ms", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &this->crash_diagnostic.watchdog_timeout_ms},
			{"VK_LAYER_LUNARG_crash_diagnostic", "output_path", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->crash_diagnostic.output_path.c_str()},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_queue_submits", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->crash_diagnostic.dump_queue_submits.c_str()},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_command_buffers", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->crash_diagnostic.dump_command_buffers.c_str()},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_commands", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->crash_diagnostic.dump_commands.c_str()},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_shaders", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->crash_diagnostic.dump_shaders.c_str()},
			{"VK_LAYER_LUNARG_crash_diagnostic", "log_file", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->crash_diagnostic.log_file.c_str()},
			{"VK_LAYER_LUNARG_crash_diagnostic", "trace_on", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->crash_diagnostic.trace_on},
			{"VK_LAYER_LUNARG_crash_diagnostic", "trace_all_semaphores", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->crash_diagnostic.trace_all_semaphores},
			{"VK_LAYER_LUNARG_crash_diagnostic", "message_severity", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->crash_diagnostic.message_severity_info.size()), &this->crash_diagnostic.message_severity_info[0]},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_trigger", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.capture_trigger.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_trigger_frames", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.capture_trigger_frames.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_frames", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.capture_frames.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_process_name", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.capture_process_name.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_file", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.capture_file.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_file_timestamp", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.capture_file_timestamp},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_file_flush", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.capture_file_flush},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_compression_type", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.capture_compression_type.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "capture_environment", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->gfxreconstruct.capture_environment_info.size()), &this->gfxreconstruct.capture_environment_info[0]},
			{"VK_LAYER_LUNARG_gfxreconstruct", "memory_tracking_mode", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.memory_tracking_mode.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "page_guard_copy_on_map", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.page_guard_copy_on_map},
			{"VK_LAYER_LUNARG_gfxreconstruct", "page_guard_separate_read", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.page_guard_separate_read},
			{"VK_LAYER_LUNARG_gfxreconstruct", "page_guard_external_memory", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.page_guard_external_memory},
			{"VK_LAYER_LUNARG_gfxreconstruct", "page_guard_persistent_memory", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.page_guard_persistent_memory},
			{"VK_LAYER_LUNARG_gfxreconstruct", "page_guard_align_buffer_sizes", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.page_guard_align_buffer_sizes},
			{"VK_LAYER_LUNARG_gfxreconstruct", "page_guard_unblock_sigsegv", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.page_guard_unblock_sigsegv},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_level", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.log_level.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_detailed", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.log_detailed},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_allow_indents", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.log_allow_indents},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_output_to_console", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.log_output_to_console},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_break_on_error", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.log_break_on_error},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_output_to_os_debug_string", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.log_output_to_os_debug_string},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_file", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->gfxreconstruct.log_file.c_str()},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_file_flush_after_write", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.log_file_flush_after_write},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_file_keep_open", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.log_file_keep_open},
			{"VK_LAYER_LUNARG_gfxreconstruct", "log_file_create_new", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->gfxreconstruct.log_file_create_new},
			{"VK_LAYER_LUNARG_screenshot", "frames", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->screenshot.frames.c_str()},
			{"VK_LAYER_LUNARG_screenshot", "dir", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->screenshot.dir.c_str()},
			{"VK_LAYER_LUNARG_screenshot", "format", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->screenshot.format.c_str()},
			{"VK_LAYER_KHRONOS_validation", "fine_grained_locking", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.fine_grained_locking},
			{"VK_LAYER_KHRONOS_validation", "validate_core", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.validate_core},
			{"VK_LAYER_KHRONOS_validation", "check_image_layout", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.check_image_layout},
			{"VK_LAYER_KHRONOS_validation", "check_command_buffer", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.check_command_buffer},
			{"VK_LAYER_KHRONOS_validation", "check_object_in_use", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.check_object_in_use},
			{"VK_LAYER_KHRONOS_validation", "check_query", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.check_query},
			{"VK_LAYER_KHRONOS_validation", "check_shaders", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.check_shaders},
			{"VK_LAYER_KHRONOS_validation", "check_shaders_caching", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.check_shaders_caching},
			{"VK_LAYER_KHRONOS_validation", "debug_disable_spirv_val", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.debug_disable_spirv_val},
			{"VK_LAYER_KHRONOS_validation", "unique_handles", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.unique_handles},
			{"VK_LAYER_KHRONOS_validation", "object_lifetime", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.object_lifetime},
			{"VK_LAYER_KHRONOS_validation", "stateless_param", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.stateless_param},
			{"VK_LAYER_KHRONOS_validation", "legacy_detection", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.legacy_detection},
			{"VK_LAYER_KHRONOS_validation", "thread_safety", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.thread_safety},
			{"VK_LAYER_KHRONOS_validation", "validate_sync", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.validate_sync},
			{"VK_LAYER_KHRONOS_validation", "syncval_submit_time_validation", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.syncval_submit_time_validation},
			{"VK_LAYER_KHRONOS_validation", "syncval_shader_accesses_heuristic", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.syncval_shader_accesses_heuristic},
			{"VK_LAYER_KHRONOS_validation", "syncval_message_extra_properties", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.syncval_message_extra_properties},
			{"VK_LAYER_KHRONOS_validation", "printf_only_preset", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.printf_only_preset},
			{"VK_LAYER_KHRONOS_validation", "printf_enable", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.printf_enable},
			{"VK_LAYER_KHRONOS_validation", "printf_to_stdout", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.printf_to_stdout},
			{"VK_LAYER_KHRONOS_validation", "printf_verbose", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.printf_verbose},
			{"VK_LAYER_KHRONOS_validation", "printf_buffer_size", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &this->validation.printf_buffer_size},
			{"VK_LAYER_KHRONOS_validation", "gpuav_enable", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_enable},
			{"VK_LAYER_KHRONOS_validation", "gpuav_safe_mode", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_safe_mode},
			{"VK_LAYER_KHRONOS_validation", "gpuav_force_on_robustness", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_force_on_robustness},
			{"VK_LAYER_KHRONOS_validation", "gpuav_shader_instrumentation", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_shader_instrumentation},
			{"VK_LAYER_KHRONOS_validation", "gpuav_select_instrumented_shaders", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_select_instrumented_shaders},
			{"VK_LAYER_KHRONOS_validation", "gpuav_shaders_to_instrument", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->validation.gpuav_shaders_to_instrument_info.size()), &this->validation.gpuav_shaders_to_instrument_info[0]},
			{"VK_LAYER_KHRONOS_validation", "gpuav_descriptor_checks", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_descriptor_checks},
			{"VK_LAYER_KHRONOS_validation", "gpuav_post_process_descriptor_indexing", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_post_process_descriptor_indexing},
			{"VK_LAYER_KHRONOS_validation", "gpuav_buffer_address_oob", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_buffer_address_oob},
			{"VK_LAYER_KHRONOS_validation", "gpuav_validate_ray_query", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_validate_ray_query},
			{"VK_LAYER_KHRONOS_validation", "gpuav_vertex_attribute_fetch_oob", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_vertex_attribute_fetch_oob},
			{"VK_LAYER_KHRONOS_validation", "gpuav_shader_sanitizer", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_shader_sanitizer},
			{"VK_LAYER_KHRONOS_validation", "gpuav_buffers_validation", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_buffers_validation},
			{"VK_LAYER_KHRONOS_validation", "gpuav_indirect_draws_buffers", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_indirect_draws_buffers},
			{"VK_LAYER_KHRONOS_validation", "gpuav_indirect_dispatches_buffers", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_indirect_dispatches_buffers},
			{"VK_LAYER_KHRONOS_validation", "gpuav_indirect_trace_rays_buffers", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_indirect_trace_rays_buffers},
			{"VK_LAYER_KHRONOS_validation", "gpuav_buffer_copies", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_buffer_copies},
			{"VK_LAYER_KHRONOS_validation", "gpuav_copy_memory_indirect", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_copy_memory_indirect},
			{"VK_LAYER_KHRONOS_validation", "gpuav_index_buffers", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_index_buffers},
			{"VK_LAYER_KHRONOS_validation", "gpuav_acceleration_structures_builds", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_acceleration_structures_builds},
			{"VK_LAYER_KHRONOS_validation", "gpuav_debug_disable_all", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_debug_disable_all},
			{"VK_LAYER_KHRONOS_validation", "gpuav_debug_validate_instrumented_shaders", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_debug_validate_instrumented_shaders},
			{"VK_LAYER_KHRONOS_validation", "gpuav_debug_dump_instrumented_shaders", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_debug_dump_instrumented_shaders},
			{"VK_LAYER_KHRONOS_validation", "gpuav_debug_max_instrumentations_count", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &this->validation.gpuav_debug_max_instrumentations_count},
			{"VK_LAYER_KHRONOS_validation", "gpuav_debug_print_instrumentation_info", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.gpuav_debug_print_instrumentation_info},
			{"VK_LAYER_KHRONOS_validation", "validate_best_practices", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.validate_best_practices},
			{"VK_LAYER_KHRONOS_validation", "validate_best_practices_arm", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.validate_best_practices_arm},
			{"VK_LAYER_KHRONOS_validation", "validate_best_practices_amd", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.validate_best_practices_amd},
			{"VK_LAYER_KHRONOS_validation", "validate_best_practices_img", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.validate_best_practices_img},
			{"VK_LAYER_KHRONOS_validation", "validate_best_practices_nvidia", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.validate_best_practices_nvidia},
			{"VK_LAYER_KHRONOS_validation", "debug_action", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->validation.debug_action_info.size()), &this->validation.debug_action_info[0]},
			{"VK_LAYER_KHRONOS_validation", "log_filename", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->validation.log_filename.c_str()},
			{"VK_LAYER_KHRONOS_validation", "report_flags", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->validation.report_flags_info.size()), &this->validation.report_flags_info[0]},
			{"VK_LAYER_KHRONOS_validation", "enable_message_limit", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.enable_message_limit},
			{"VK_LAYER_KHRONOS_validation", "duplicate_message_limit", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &this->validation.duplicate_message_limit},
			{"VK_LAYER_KHRONOS_validation", "message_id_filter", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->validation.message_id_filter_info.size()), &this->validation.message_id_filter_info[0]},
			{"VK_LAYER_KHRONOS_validation", "message_format_json", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.message_format_json},
			{"VK_LAYER_KHRONOS_validation", "message_format_display_application_name", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->validation.message_format_display_application_name},
			{"VK_LAYER_KHRONOS_profiles", "profile_emulation", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.profile_emulation},
			{"VK_LAYER_KHRONOS_profiles", "profile_dirs", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->profiles.profile_dirs.c_str()},
			{"VK_LAYER_KHRONOS_profiles", "profile_name", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->profiles.profile_name.c_str()},
			{"VK_LAYER_KHRONOS_profiles", "profile_validation", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.profile_validation},
			{"VK_LAYER_KHRONOS_profiles", "simulate_capabilities", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->profiles.simulate_capabilities_info.size()), &this->profiles.simulate_capabilities_info[0]},
			{"VK_LAYER_KHRONOS_profiles", "default_feature_values", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->profiles.default_feature_values.c_str()},
			{"VK_LAYER_KHRONOS_profiles", "unknown_feature_values", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->profiles.unknown_feature_values.c_str()},
			{"VK_LAYER_KHRONOS_profiles", "emulate_portability", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.emulate_portability},
			{"VK_LAYER_KHRONOS_profiles", "constantAlphaColorBlendFactors", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.constantAlphaColorBlendFactors},
			{"VK_LAYER_KHRONOS_profiles", "events", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.events},
			{"VK_LAYER_KHRONOS_profiles", "imageViewFormatReinterpretation", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.imageViewFormatReinterpretation},
			{"VK_LAYER_KHRONOS_profiles", "imageViewFormatSwizzle", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.imageViewFormatSwizzle},
			{"VK_LAYER_KHRONOS_profiles", "imageView2DOn3DImage", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.imageView2DOn3DImage},
			{"VK_LAYER_KHRONOS_profiles", "multisampleArrayImage", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.multisampleArrayImage},
			{"VK_LAYER_KHRONOS_profiles", "mutableComparisonSamplers", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.mutableComparisonSamplers},
			{"VK_LAYER_KHRONOS_profiles", "pointPolygons", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.pointPolygons},
			{"VK_LAYER_KHRONOS_profiles", "samplerMipLodBias", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.samplerMipLodBias},
			{"VK_LAYER_KHRONOS_profiles", "separateStencilMaskRef", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.separateStencilMaskRef},
			{"VK_LAYER_KHRONOS_profiles", "shaderSampleRateInterpolationFunctions", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.shaderSampleRateInterpolationFunctions},
			{"VK_LAYER_KHRONOS_profiles", "tessellationIsolines", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.tessellationIsolines},
			{"VK_LAYER_KHRONOS_profiles", "triangleFans", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.triangleFans},
			{"VK_LAYER_KHRONOS_profiles", "vertexAttributeAccessBeyondStride", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.vertexAttributeAccessBeyondStride},
			{"VK_LAYER_KHRONOS_profiles", "minVertexInputBindingStrideAlignment", VK_LAYER_SETTING_TYPE_INT32_EXT, 1, &this->profiles.minVertexInputBindingStrideAlignment},
			{"VK_LAYER_KHRONOS_profiles", "exclude_device_extensions", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->profiles.exclude_device_extensions_info.size()), &this->profiles.exclude_device_extensions_info[0]},
			{"VK_LAYER_KHRONOS_profiles", "exclude_formats", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->profiles.exclude_formats_info.size()), &this->profiles.exclude_formats_info[0]},
			{"VK_LAYER_KHRONOS_profiles", "debug_actions", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->profiles.debug_actions_info.size()), &this->profiles.debug_actions_info[0]},
			{"VK_LAYER_KHRONOS_profiles", "debug_filename", VK_LAYER_SETTING_TYPE_STRING_EXT, 1, this->profiles.debug_filename.c_str()},
			{"VK_LAYER_KHRONOS_profiles", "debug_file_clear", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.debug_file_clear},
			{"VK_LAYER_KHRONOS_profiles", "debug_fail_on_error", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->profiles.debug_fail_on_error},
			{"VK_LAYER_KHRONOS_profiles", "debug_reports", VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast<uint32_t>(this->profiles.debug_reports_info.size()), &this->profiles.debug_reports_info[0]},
			{"VK_LAYER_KHRONOS_shader_object", "force_enable", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->shader_object.force_enable},
			{"VK_LAYER_KHRONOS_shader_object", "disable_pipeline_pre_caching", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->shader_object.disable_pipeline_pre_caching},
			{"VK_LAYER_KHRONOS_synchronization2", "force_enable", VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &this->synchronization2.force_enable},
		};
		return init;
	};
};

